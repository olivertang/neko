'use strict';

var reactNativePasskey = require('react-native-passkey');
var encoding = require('@turnkey/encoding');
var util = require('./util.js');

/**
 * Header name for a webauthn stamp
 */
const stampHeaderName = "X-Stamp-Webauthn";
const defaultTimeout = 5 * 60 * 1000; // five minutes
const defaultUserVerification = "preferred";
/**
 * Re-export of the underlying library's `isSupported` method
 */
function isSupported() {
    return reactNativePasskey.Passkey.isSupported();
}
/**
 * Creates a passkey and returns authenticator params
 */
async function createPasskey(config, options) {
    const challenge = config.challenge || util.getRandomChallenge();
    const registrationResult = await reactNativePasskey.Passkey.register({
        challenge: challenge,
        rp: config.rp,
        user: config.user,
        excludeCredentials: config.excludeCredentials || [],
        authenticatorSelection: config.authenticatorSelection || {
            requireResidentKey: true,
            residentKey: "required",
            userVerification: "preferred",
        },
        attestation: config.attestation || "none",
        extensions: config.extensions || {},
        // All algorithms can be found here: https://www.iana.org/assignments/cose/cose.xhtml#algorithms
        // We only support ES256 and RS256, which are listed below
        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7,
            },
            {
                type: "public-key",
                alg: -257,
            },
        ],
    }, options);
    return {
        authenticatorName: config.authenticatorName,
        challenge: challenge,
        attestation: {
            credentialId: encoding.base64StringToBase64UrlEncodedString(registrationResult.id),
            clientDataJson: encoding.base64StringToBase64UrlEncodedString(registrationResult.response.clientDataJSON),
            attestationObject: encoding.base64StringToBase64UrlEncodedString(registrationResult.response.attestationObject),
            // TODO: can we infer the transport from the registration result?
            // In all honesty this isn't critical so we default to "hybrid" because that's the transport used by passkeys.
            transports: ["AUTHENTICATOR_TRANSPORT_HYBRID"],
        },
    };
}
/**
 * Stamper to use with `@turnkey/http`'s `TurnkeyClient`
 */
class PasskeyStamper {
    constructor(config) {
        this.rpId = config.rpId;
        this.timeout = config.timeout || defaultTimeout;
        this.userVerification = config.userVerification || defaultUserVerification;
        this.allowCredentials = config.allowCredentials || [];
        this.extensions = config.extensions || {};
    }
    async stamp(payload) {
        const challenge = util.getChallengeFromPayload(payload);
        const signingOptions = {
            challenge: challenge,
            rpId: this.rpId,
            timeout: this.timeout,
            allowCredentials: this.allowCredentials,
            userVerification: this.userVerification,
            extensions: this.extensions,
        };
        const authenticationResult = await reactNativePasskey.Passkey.authenticate(signingOptions);
        const stamp = {
            authenticatorData: encoding.base64StringToBase64UrlEncodedString(authenticationResult.response.authenticatorData),
            clientDataJson: encoding.base64StringToBase64UrlEncodedString(authenticationResult.response.clientDataJSON),
            credentialId: encoding.base64StringToBase64UrlEncodedString(authenticationResult.id),
            signature: encoding.base64StringToBase64UrlEncodedString(authenticationResult.response.signature),
        };
        return {
            stampHeaderName: stampHeaderName,
            stampHeaderValue: JSON.stringify(stamp),
        };
    }
}

exports.PasskeyStamper = PasskeyStamper;
exports.createPasskey = createPasskey;
exports.isSupported = isSupported;
//# sourceMappingURL=index.js.map
