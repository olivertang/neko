"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createKernelAccount = exports.KERNEL_ADDRESSES = void 0;
const permissionless_1 = require("permissionless");
const accounts_1 = require("permissionless/accounts");
const viem_1 = require("viem");
const constants_js_1 = require("../../constants.js");
const utils_js_1 = require("../../utils.js");
const utils_js_2 = require("../../utils.js");
const index_js_1 = require("../utils/index.js");
const toKernelPluginManager_js_1 = require("../utils/toKernelPluginManager.js");
const KernelAccountAbi_js_1 = require("./abi/KernelAccountAbi.js");
const KernelAccountAbi_js_2 = require("./abi/kernel_v_3_0_0/KernelAccountAbi.js");
const KernelFactoryAbi_js_1 = require("./abi/kernel_v_3_0_0/KernelFactoryAbi.js");
const KernelFactoryStakerAbi_js_1 = require("./abi/kernel_v_3_0_0/KernelFactoryStakerAbi.js");
const KernelAccountAbi_js_3 = require("./abi/kernel_v_3_1/KernelAccountAbi.js");
const encodeCallData_js_1 = require("./utils/account/ep0_6/encodeCallData.js");
const encodeDeployCallData_js_1 = require("./utils/account/ep0_6/encodeDeployCallData.js");
const encodeCallData_js_2 = require("./utils/account/ep0_7/encodeCallData.js");
const encodeDeployCallData_js_2 = require("./utils/account/ep0_7/encodeDeployCallData.js");
const accountMetadata_js_1 = require("./utils/common/accountMetadata.js");
const eip712WrapHash_js_1 = require("./utils/common/eip712WrapHash.js");
const createAccountAbi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_implementation",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256"
            }
        ],
        name: "createAccount",
        outputs: [
            {
                internalType: "address",
                name: "proxy",
                type: "address"
            }
        ],
        stateMutability: "payable",
        type: "function"
    }
];
exports.KERNEL_ADDRESSES = {
    ACCOUNT_LOGIC_V0_6: "0xd3082872F8B06073A021b4602e022d5A070d7cfC",
    ACCOUNT_LOGIC_V0_7: "0x94F097E1ebEB4ecA3AAE54cabb08905B239A7D27",
    FACTORY_ADDRESS_V0_6: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3",
    FACTORY_ADDRESS_V0_7: "0x6723b44Abeec4E71eBE3232BD5B455805baDD22f",
    FACTORY_STAKER: "0xd703aaE79538628d27099B8c4f621bE4CCd142d5"
};
const getKernelInitData = async ({ entryPoint: entryPointAddress, kernelPluginManager, initHook, kernelVersion, initConfig }) => {
    const entryPointVersion = (0, permissionless_1.getEntryPointVersion)(entryPointAddress);
    const { enableData, identifier, validatorAddress, initConfig: initConfig_ } = await kernelPluginManager.getValidatorInitData();
    if (entryPointVersion === "v0.6") {
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_1.KernelInitAbi,
            functionName: "initialize",
            args: [validatorAddress, enableData]
        });
    }
    if (kernelVersion === "0.3.0") {
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_2.KernelV3InitAbi,
            functionName: "initialize",
            args: [
                identifier,
                initHook && kernelPluginManager.hook
                    ? kernelPluginManager.hook?.getIdentifier()
                    : viem_1.zeroAddress,
                enableData,
                initHook && kernelPluginManager.hook
                    ? await kernelPluginManager.hook?.getEnableData()
                    : "0x"
            ]
        });
    }
    return (0, viem_1.encodeFunctionData)({
        abi: KernelAccountAbi_js_3.KernelV3_1AccountAbi,
        functionName: "initialize",
        args: [
            identifier,
            initHook && kernelPluginManager.hook
                ? kernelPluginManager.hook?.getIdentifier()
                : viem_1.zeroAddress,
            enableData,
            initHook && kernelPluginManager.hook
                ? await kernelPluginManager.hook?.getEnableData()
                : "0x",
            initConfig ?? initConfig_ ?? []
        ]
    });
};
const getAccountInitCode = async ({ index, factoryAddress, accountImplementationAddress, metaFactoryAddress, entryPoint: entryPointAddress, kernelPluginManager, initHook, kernelVersion, initConfig, useMetaFactory }) => {
    const initialisationData = await getKernelInitData({
        entryPoint: entryPointAddress,
        kernelPluginManager,
        initHook,
        kernelVersion,
        initConfig
    });
    const entryPointVersion = (0, permissionless_1.getEntryPointVersion)(entryPointAddress);
    if (entryPointVersion === "v0.6") {
        return (0, viem_1.concatHex)([
            factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: createAccountAbi,
                functionName: "createAccount",
                args: [accountImplementationAddress, initialisationData, index]
            })
        ]);
    }
    if (!useMetaFactory) {
        return (0, viem_1.concatHex)([
            factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: KernelFactoryAbi_js_1.KernelV3FactoryAbi,
                functionName: "createAccount",
                args: [initialisationData, (0, viem_1.toHex)(index, { size: 32 })]
            })
        ]);
    }
    return (0, viem_1.concatHex)([
        metaFactoryAddress ?? viem_1.zeroAddress,
        (0, viem_1.encodeFunctionData)({
            abi: KernelFactoryStakerAbi_js_1.KernelFactoryStakerAbi,
            functionName: "deployWithFactory",
            args: [
                factoryAddress,
                initialisationData,
                (0, viem_1.toHex)(index, { size: 32 })
            ]
        })
    ]);
};
const getAccountAddress = async ({ client, entryPoint: entryPointAddress, initCodeProvider }) => {
    const entryPointVersion = (0, permissionless_1.getEntryPointVersion)(entryPointAddress);
    const initCode = await initCodeProvider();
    if (entryPointVersion === "v0.6") {
        return (0, permissionless_1.getSenderAddress)(client, {
            initCode,
            entryPoint: entryPointAddress
        });
    }
    return (0, permissionless_1.getSenderAddress)(client, {
        factory: (0, index_js_1.parseFactoryAddressAndCallDataFromAccountInitCode)(initCode)[0],
        factoryData: (0, index_js_1.parseFactoryAddressAndCallDataFromAccountInitCode)(initCode)[1],
        entryPoint: entryPointAddress
    });
};
const getDefaultAddresses = (entryPointAddress, kernelVersion, { accountImplementationAddress, factoryAddress, metaFactoryAddress }) => {
    (0, utils_js_2.validateKernelVersionWithEntryPoint)(entryPointAddress, kernelVersion);
    const addresses = constants_js_1.KernelVersionToAddressesMap[kernelVersion];
    if (!addresses) {
        throw new Error(`No addresses found for kernel version ${kernelVersion}`);
    }
    return {
        accountImplementationAddress: accountImplementationAddress ??
            addresses.accountImplementationAddress,
        factoryAddress: factoryAddress ?? addresses.factoryAddress,
        metaFactoryAddress: metaFactoryAddress ?? addresses.metaFactoryAddress
    };
};
async function createKernelAccount(client, { plugins, entryPoint: entryPointAddress, index = 0n, factoryAddress: _factoryAddress, accountImplementationAddress: _accountImplementationAddress, metaFactoryAddress: _metaFactoryAddress, deployedAccountAddress, kernelVersion, initConfig, useMetaFactory = true, chainId }) {
    const entryPointVersion = (0, permissionless_1.getEntryPointVersion)(entryPointAddress);
    const { accountImplementationAddress, factoryAddress, metaFactoryAddress } = getDefaultAddresses(entryPointAddress, kernelVersion, {
        accountImplementationAddress: _accountImplementationAddress,
        factoryAddress: _factoryAddress,
        metaFactoryAddress: _metaFactoryAddress
    });
    const kernelPluginManager = (0, toKernelPluginManager_js_1.isKernelPluginManager)(plugins)
        ? plugins
        : await (0, toKernelPluginManager_js_1.toKernelPluginManager)(client, {
            sudo: plugins.sudo,
            regular: plugins.regular,
            hook: plugins.hook,
            action: plugins.action,
            pluginEnableSignature: plugins.pluginEnableSignature,
            entryPoint: entryPointAddress,
            kernelVersion,
            chainId
        });
    const initHook = Boolean((0, toKernelPluginManager_js_1.isKernelPluginManager)(plugins)
        ? plugins.hook &&
            plugins.getIdentifier() ===
                plugins.sudoValidator?.getIdentifier()
        : plugins.hook && !plugins.regular);
    const generateInitCode = async () => {
        if (!accountImplementationAddress || !factoryAddress)
            throw new Error("Missing account logic address or factory address");
        return getAccountInitCode({
            index,
            factoryAddress,
            accountImplementationAddress,
            metaFactoryAddress,
            entryPoint: entryPointAddress,
            kernelPluginManager,
            initHook,
            kernelVersion,
            initConfig,
            useMetaFactory
        });
    };
    const accountAddress = deployedAccountAddress ??
        (await getAccountAddress({
            client,
            entryPoint: entryPointAddress,
            initCodeProvider: generateInitCode
        }));
    if (!accountAddress)
        throw new Error("Account address not found");
    let smartAccountDeployed = await (0, permissionless_1.isSmartAccountDeployed)(client, accountAddress);
    return {
        kernelVersion,
        kernelPluginManager,
        generateInitCode,
        encodeModuleInstallCallData: async () => {
            return await kernelPluginManager.encodeModuleInstallCallData(accountAddress);
        },
        ...(0, accounts_1.toSmartAccount)({
            address: accountAddress,
            publicKey: accountAddress,
            source: "kernelSmartAccount",
            client,
            entryPoint: entryPointAddress,
            async encodeDeployCallData(_tx) {
                if (entryPointVersion === "v0.6") {
                    return (0, encodeDeployCallData_js_1.encodeDeployCallData)(_tx);
                }
                return (0, encodeDeployCallData_js_2.encodeDeployCallData)(_tx);
            },
            async encodeCallData(_tx) {
                const tx = _tx;
                if (!Array.isArray(tx) &&
                    (!tx.callType || tx.callType === "call") &&
                    tx.to.toLowerCase() === accountAddress.toLowerCase()) {
                    return tx.data;
                }
                if (entryPointVersion === "v0.6") {
                    return (0, encodeCallData_js_1.encodeCallData)(tx);
                }
                if (plugins.hook) {
                    return (0, encodeCallData_js_2.encodeCallData)(tx, true);
                }
                return (0, encodeCallData_js_2.encodeCallData)(tx);
            },
            async getFactory() {
                if (smartAccountDeployed)
                    return undefined;
                smartAccountDeployed = await (0, permissionless_1.isSmartAccountDeployed)(client, accountAddress);
                if (smartAccountDeployed)
                    return undefined;
                const entryPointVersion = (0, permissionless_1.getEntryPointVersion)(entryPointAddress);
                if (entryPointVersion === "v0.6") {
                    return factoryAddress;
                }
                if (!useMetaFactory) {
                    return factoryAddress;
                }
                return metaFactoryAddress;
            },
            async getFactoryData() {
                if (smartAccountDeployed)
                    return undefined;
                smartAccountDeployed = await (0, permissionless_1.isSmartAccountDeployed)(client, accountAddress);
                if (smartAccountDeployed)
                    return undefined;
                return (0, index_js_1.parseFactoryAddressAndCallDataFromAccountInitCode)(await generateInitCode())[1];
            },
            async signMessage({ message }) {
                const messageHash = (0, viem_1.hashMessage)(message);
                const { name, chainId: metadataChainId, version } = await (0, accountMetadata_js_1.accountMetadata)(client, accountAddress, kernelVersion, chainId);
                const wrappedMessageHash = await (0, eip712WrapHash_js_1.eip712WrapHash)(messageHash, {
                    name,
                    chainId: Number(metadataChainId),
                    version,
                    verifyingContract: accountAddress
                });
                const signature = await kernelPluginManager.signMessage({
                    message: { raw: wrappedMessageHash }
                });
                if (!(0, utils_js_1.hasKernelFeature)(utils_js_1.KERNEL_FEATURES.ERC1271_WITH_VALIDATOR, version)) {
                    return signature;
                }
                return (0, viem_1.concatHex)([
                    kernelPluginManager.getIdentifier(),
                    signature
                ]);
            },
            async signTransaction(_, __) {
                throw new accounts_1.SignTransactionNotSupportedBySmartAccount();
            },
            async signTypedData(typedData) {
                const types = {
                    EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({
                        domain: typedData.domain
                    }),
                    ...typedData.types
                };
                (0, viem_1.validateTypedData)({
                    domain: typedData.domain,
                    message: typedData.message,
                    primaryType: typedData.primaryType,
                    types: types
                });
                const typedHash = (0, viem_1.hashTypedData)(typedData);
                const { name, chainId: metadataChainId, version } = await (0, accountMetadata_js_1.accountMetadata)(client, accountAddress, kernelVersion, chainId);
                const wrappedMessageHash = await (0, eip712WrapHash_js_1.eip712WrapHash)(typedHash, {
                    name,
                    chainId: Number(metadataChainId),
                    version,
                    verifyingContract: accountAddress
                });
                const signature = await kernelPluginManager.signMessage({
                    message: { raw: wrappedMessageHash }
                });
                if (!(0, utils_js_1.hasKernelFeature)(utils_js_1.KERNEL_FEATURES.ERC1271_WITH_VALIDATOR, version)) {
                    return signature;
                }
                return (0, viem_1.concatHex)([
                    kernelPluginManager.getIdentifier(),
                    signature
                ]);
            },
            async getNonce(customNonceKey) {
                const key = await kernelPluginManager.getNonceKey(accountAddress, customNonceKey);
                return (0, permissionless_1.getAccountNonce)(client, {
                    sender: accountAddress,
                    entryPoint: entryPointAddress,
                    key
                });
            },
            async signUserOperation(userOperation) {
                return kernelPluginManager.signUserOperation(userOperation);
            },
            async getDummySignature(userOperation) {
                return kernelPluginManager.getDummySignature(userOperation);
            },
            async getInitCode() {
                if (smartAccountDeployed)
                    return "0x";
                smartAccountDeployed = await (0, permissionless_1.isSmartAccountDeployed)(client, accountAddress);
                if (smartAccountDeployed)
                    return "0x";
                return generateInitCode();
            }
        })
    };
}
exports.createKernelAccount = createKernelAccount;
//# sourceMappingURL=createKernelAccount.js.map