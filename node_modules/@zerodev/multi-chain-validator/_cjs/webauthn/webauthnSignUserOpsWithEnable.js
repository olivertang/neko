"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webauthnSignUserOpsWithEnable = void 0;
const sdk_1 = require("@zerodev/sdk");
const merkletreejs_1 = require("merkletreejs");
const viem_1 = require("viem");
const webauthnSignUserOpsWithEnable = async ({ multiChainUserOpConfigsForEnable }) => {
    const pluginEnableTypedDatas = await Promise.all(multiChainUserOpConfigsForEnable.map(async (config) => {
        return config.account.kernelPluginManager.getPluginsEnableTypedData(config.account.address);
    }));
    const leaves = pluginEnableTypedDatas.map((typedData) => {
        return (0, viem_1.hashTypedData)(typedData);
    });
    const merkleTree = new merkletreejs_1.MerkleTree(leaves, viem_1.keccak256, {
        sortPairs: true
    });
    const merkleRoot = merkleTree.getHexRoot();
    const toEthSignedMessageHash = (0, viem_1.hashMessage)({ raw: merkleRoot });
    const passkeySig = await multiChainUserOpConfigsForEnable[0].account.kernelPluginManager.sudoValidator?.signMessage({
        message: {
            raw: toEthSignedMessageHash
        }
    });
    if (!passkeySig) {
        throw new Error("No passkeySig, check if the sudo validator is multi-chain validator");
    }
    const enableSigs = multiChainUserOpConfigsForEnable.map((_, index) => {
        const merkleProof = merkleTree.getHexProof(leaves[index]);
        const encodedMerkleProof = (0, viem_1.encodeAbiParameters)([{ name: "proof", type: "bytes32[]" }], [merkleProof]);
        const merkleData = (0, viem_1.concatHex)([merkleRoot, encodedMerkleProof]);
        return (0, viem_1.encodeAbiParameters)([
            {
                name: "merkleData",
                type: "bytes"
            },
            {
                name: "signature",
                type: "bytes"
            }
        ], [merkleData, passkeySig]);
    });
    const userOpSignatures = await Promise.all(multiChainUserOpConfigsForEnable.map(async (config) => {
        return config.account.kernelPluginManager.signUserOperationWithActiveValidator(config.userOp);
    }));
    const action = {
        selector: (0, viem_1.toFunctionSelector)((0, viem_1.getAbiItem)({ abi: sdk_1.KernelV3AccountAbi, name: "execute" })),
        address: viem_1.zeroAddress
    };
    const finalSignatures = await Promise.all(multiChainUserOpConfigsForEnable.map(async (config, index) => {
        return await (0, sdk_1.getEncodedPluginsData)({
            enableSignature: enableSigs[index],
            userOpSignature: userOpSignatures[index],
            action,
            enableData: await config.account.kernelPluginManager.getEnableData(config.account.address)
        });
    }));
    return multiChainUserOpConfigsForEnable.map((config, index) => {
        return {
            ...config.userOp,
            signature: finalSignatures[index]
        };
    });
};
exports.webauthnSignUserOpsWithEnable = webauthnSignUserOpsWithEnable;
//# sourceMappingURL=webauthnSignUserOpsWithEnable.js.map