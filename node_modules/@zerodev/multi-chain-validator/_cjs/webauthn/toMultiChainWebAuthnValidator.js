"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeMultiChainWebAuthnValidator = exports.toMultiChainWebAuthnValidator = void 0;
const webauthn_key_1 = require("@zerodev/webauthn-key");
const permissionless_1 = require("permissionless");
const accounts_1 = require("permissionless/accounts");
const viem_1 = require("viem");
const accounts_2 = require("viem/accounts");
const actions_1 = require("viem/actions");
const constants_js_1 = require("../constants.js");
const signMessageUsingWebAuthn = async (message, chainId, rpId, allowCredentials) => {
    let messageContent;
    if (typeof message === "string") {
        messageContent = message;
    }
    else if ("raw" in message && typeof message.raw === "string") {
        messageContent = message.raw;
    }
    else if ("raw" in message && message.raw instanceof Uint8Array) {
        messageContent = message.raw.toString();
    }
    else {
        throw new Error("Unsupported message format");
    }
    const formattedMessage = messageContent.startsWith("0x")
        ? messageContent.slice(2)
        : messageContent;
    const challenge = (0, webauthn_key_1.base64FromUint8Array)((0, webauthn_key_1.hexStringToUint8Array)(formattedMessage), true);
    const assertionOptions = {
        challenge,
        allowCredentials,
        userVerification: "required",
        rpId
    };
    const { startAuthentication } = await Promise.resolve().then(() => require("@simplewebauthn/browser"));
    const cred = await startAuthentication(assertionOptions);
    const { authenticatorData } = cred.response;
    const authenticatorDataHex = (0, webauthn_key_1.uint8ArrayToHexString)((0, webauthn_key_1.b64ToBytes)(authenticatorData));
    const clientDataJSON = atob(cred.response.clientDataJSON);
    const { beforeType } = (0, webauthn_key_1.findQuoteIndices)(clientDataJSON);
    const { signature } = cred.response;
    const signatureHex = (0, webauthn_key_1.uint8ArrayToHexString)((0, webauthn_key_1.b64ToBytes)(signature));
    const { r, s } = (0, webauthn_key_1.parseAndNormalizeSig)(signatureHex);
    const encodedSignature = (0, viem_1.encodeAbiParameters)([
        { name: "authenticatorData", type: "bytes" },
        { name: "clientDataJSON", type: "string" },
        { name: "responseTypeLocation", type: "uint256" },
        { name: "r", type: "uint256" },
        { name: "s", type: "uint256" },
        { name: "usePrecompiled", type: "bool" }
    ], [
        authenticatorDataHex,
        clientDataJSON,
        beforeType,
        BigInt(r),
        BigInt(s),
        (0, webauthn_key_1.isRIP7212SupportedNetwork)(chainId)
    ]);
    return encodedSignature;
};
async function toMultiChainWebAuthnValidator(client, { webAuthnKey, entryPoint: entryPointAddress, kernelVersion: _, rpId, validatorAddress }) {
    const currentValidatorAddress = validatorAddress ?? constants_js_1.MULTI_CHAIN_WEBAUTHN_VALIDATOR_ADDRESS;
    const chainId = await (0, actions_1.getChainId)(client);
    const account = (0, accounts_2.toAccount)({
        address: "0x0000000000000000000000000000000000000000",
        async signMessage({ message }) {
            return signMessageUsingWebAuthn(message, chainId, rpId, [
                { id: webAuthnKey.authenticatorId, type: "public-key" }
            ]);
        },
        async signTransaction(_, __) {
            throw new accounts_1.SignTransactionNotSupportedBySmartAccount();
        },
        async signTypedData(typedData) {
            const { domain, message, primaryType } = typedData;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...typedData.types
            };
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const hash = (0, viem_1.hashTypedData)(typedData);
            const signature = await (0, actions_1.signMessage)(client, {
                account,
                message: hash
            });
            return signature;
        }
    });
    return {
        ...account,
        supportedKernelVersions: ">=0.3.0",
        validatorType: "SECONDARY",
        address: currentValidatorAddress,
        source: "MultiChainWebAuthnValidator",
        getIdentifier() {
            return (currentValidatorAddress ??
                constants_js_1.MULTI_CHAIN_WEBAUTHN_VALIDATOR_ADDRESS);
        },
        async getEnableData() {
            return (0, viem_1.encodeAbiParameters)([
                {
                    components: [
                        { name: "x", type: "uint256" },
                        { name: "y", type: "uint256" }
                    ],
                    name: "webAuthnData",
                    type: "tuple"
                },
                {
                    name: "authenticatorIdHash",
                    type: "bytes32"
                }
            ], [
                {
                    x: webAuthnKey.pubX,
                    y: webAuthnKey.pubY
                },
                webAuthnKey.authenticatorIdHash
            ]);
        },
        async getNonceKey(_accountAddress, customNonceKey) {
            if (customNonceKey) {
                return customNonceKey;
            }
            return 0n;
        },
        async signUserOperation(userOperation) {
            const hash = (0, permissionless_1.getUserOperationHash)({
                userOperation: {
                    ...userOperation,
                    signature: "0x"
                },
                entryPoint: entryPointAddress,
                chainId: chainId
            });
            const signature = await (0, actions_1.signMessage)(client, {
                account,
                message: { raw: hash }
            });
            const encodedSignature = (0, viem_1.encodeAbiParameters)([
                {
                    name: "merkleData",
                    type: "bytes"
                },
                {
                    name: "signature",
                    type: "bytes"
                }
            ], ["0x", signature]);
            return encodedSignature;
        },
        async getDummySignature(_userOperation) {
            const signature = (0, viem_1.encodeAbiParameters)([
                { name: "authenticatorData", type: "bytes" },
                { name: "clientDataJSON", type: "string" },
                { name: "responseTypeLocation", type: "uint256" },
                { name: "r", type: "uint256" },
                { name: "s", type: "uint256" },
                { name: "usePrecompiled", type: "bool" }
            ], [
                "0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97631d00000000",
                '{"type":"webauthn.get","challenge":"tbxXNFS9X_4Byr1cMwqKrIGB-_30a0QhZ6y7ucM0BOE","origin":"http://localhost:3000","crossOrigin":false, "other_keys_can_be_added_here":"do not compare clientDataJSON against a template. See https://goo.gl/yabPex"}',
                1n,
                44941127272049826721201904734628716258498742255959991581049806490182030242267n,
                9910254599581058084911561569808925251374718953855182016200087235935345969636n,
                false
            ]);
            return (0, viem_1.encodeAbiParameters)([
                { name: "merkleData", type: "bytes" },
                { name: "signature", type: "bytes" }
            ], ["0x", signature]);
        },
        async isEnabled(_kernelAccountAddress, _selector) {
            return false;
        },
        getSerializedData() {
            return serializeMultiChainWebAuthnValidatorData({
                entryPoint: entryPointAddress,
                validatorAddress: currentValidatorAddress,
                pubKeyX: webAuthnKey.pubX,
                pubKeyY: webAuthnKey.pubY,
                authenticatorId: webAuthnKey.authenticatorId,
                authenticatorIdHash: webAuthnKey.authenticatorIdHash,
                rpId
            });
        }
    };
}
exports.toMultiChainWebAuthnValidator = toMultiChainWebAuthnValidator;
async function deserializeMultiChainWebAuthnValidator(client, { serializedData, entryPoint: entryPointAddress, kernelVersion }) {
    const { entryPoint, validatorAddress, pubKeyX, pubKeyY, authenticatorId, authenticatorIdHash, rpId } = deserializeMultiChainWebAuthnValidatorData(serializedData);
    const chainId = await (0, actions_1.getChainId)(client);
    const account = (0, accounts_2.toAccount)({
        address: "0x0000000000000000000000000000000000000000",
        async signMessage({ message }) {
            return signMessageUsingWebAuthn(message, chainId, rpId, [
                { id: authenticatorId, type: "public-key" }
            ]);
        },
        async signTransaction(_, __) {
            throw new accounts_1.SignTransactionNotSupportedBySmartAccount();
        },
        async signTypedData(typedData) {
            const { domain, message, primaryType } = typedData;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...typedData.types
            };
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const hash = (0, viem_1.hashTypedData)(typedData);
            const signature = await (0, actions_1.signMessage)(client, {
                account,
                message: hash
            });
            return signature;
        }
    });
    return {
        ...account,
        supportedKernelVersions: kernelVersion,
        validatorType: "SECONDARY",
        address: validatorAddress,
        source: "MultiChainWebAuthnValidator",
        getIdentifier() {
            return validatorAddress;
        },
        async getEnableData() {
            return (0, viem_1.encodeAbiParameters)([
                {
                    components: [
                        { name: "x", type: "uint256" },
                        { name: "y", type: "uint256" }
                    ],
                    name: "webAuthnData",
                    type: "tuple"
                },
                {
                    name: "authenticatorIdHash",
                    type: "bytes32"
                }
            ], [
                {
                    x: pubKeyX,
                    y: pubKeyY
                },
                authenticatorIdHash
            ]);
        },
        async getNonceKey(_accountAddress, customNonceKey) {
            if (customNonceKey) {
                return customNonceKey;
            }
            return 0n;
        },
        async signUserOperation(userOperation) {
            const hash = (0, permissionless_1.getUserOperationHash)({
                userOperation: {
                    ...userOperation,
                    signature: "0x"
                },
                entryPoint: entryPointAddress,
                chainId: chainId
            });
            const signature = await (0, actions_1.signMessage)(client, {
                account,
                message: { raw: hash }
            });
            const encodedSignature = (0, viem_1.encodeAbiParameters)([
                {
                    name: "merkleData",
                    type: "bytes"
                },
                {
                    name: "signature",
                    type: "bytes"
                }
            ], ["0x", signature]);
            return encodedSignature;
        },
        async getDummySignature(_userOperation) {
            const signature = (0, viem_1.encodeAbiParameters)([
                { name: "authenticatorData", type: "bytes" },
                { name: "clientDataJSON", type: "string" },
                { name: "responseTypeLocation", type: "uint256" },
                { name: "r", type: "uint256" },
                { name: "s", type: "uint256" },
                { name: "usePrecompiled", type: "bool" }
            ], [
                "0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97631d00000000",
                '{"type":"webauthn.get","challenge":"tbxXNFS9X_4Byr1cMwqKrIGB-_30a0QhZ6y7ucM0BOE","origin":"http://localhost:3000","crossOrigin":false, "other_keys_can_be_added_here":"do not compare clientDataJSON against a template. See https://goo.gl/yabPex"}',
                1n,
                44941127272049826721201904734628716258498742255959991581049806490182030242267n,
                9910254599581058084911561569808925251374718953855182016200087235935345969636n,
                false
            ]);
            return (0, viem_1.encodeAbiParameters)([
                { name: "merkleData", type: "bytes" },
                { name: "signature", type: "bytes" }
            ], ["0x", signature]);
        },
        async isEnabled(_kernelAccountAddress, _selector) {
            return false;
        },
        getSerializedData() {
            return serializeMultiChainWebAuthnValidatorData({
                entryPoint,
                validatorAddress,
                pubKeyX,
                pubKeyY,
                authenticatorId,
                authenticatorIdHash,
                rpId
            });
        }
    };
}
exports.deserializeMultiChainWebAuthnValidator = deserializeMultiChainWebAuthnValidator;
function serializeMultiChainWebAuthnValidatorData(params) {
    const replacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        if (value instanceof Uint8Array) {
            return Array.from(value);
        }
        return value;
    };
    const jsonString = JSON.stringify(params, replacer);
    const uint8Array = new TextEncoder().encode(jsonString);
    return bytesToBase64(uint8Array);
}
function deserializeMultiChainWebAuthnValidatorData(serializedData) {
    const uint8Array = base64ToBytes(serializedData);
    const jsonString = new TextDecoder().decode(uint8Array);
    const parsed = JSON.parse(jsonString, (_, value) => {
        if (Array.isArray(value) &&
            value.every((item) => typeof item === "number")) {
            return new Uint8Array(value);
        }
        if (typeof value === "string" && /^\d+$/.test(value)) {
            return BigInt(value);
        }
        return value;
    });
    return parsed;
}
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(bytes) {
    const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
    return btoa(binString);
}
//# sourceMappingURL=toMultiChainWebAuthnValidator.js.map