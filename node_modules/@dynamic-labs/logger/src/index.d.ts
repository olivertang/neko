import EventEmitter from 'eventemitter3';
import { LogLevel, Message } from './types';
import { MetaData } from './MetaData';
export { LogLevel, type Message } from './types';
type EmitHttpOptions = {
    args?: any[];
    transformMeta?: (meta: Record<string, any> | undefined) => Record<string, any> | undefined;
};
export type InstrumentOptions = {
    extraArgs?: NonNullable<EmitHttpOptions['args']>;
    /** Identifies which resource is being instrumented */
    key: string;
    /** Instrumentation does not use meta so this needs to be explicit */
    environmentId: string;
    /** Measurement in MS the operation took to complete */
    time: number;
    appName?: string;
    userId?: string;
    primaryWalletId?: string;
};
export declare class Logger {
    private name;
    private level;
    private static globalKeys;
    static globalMetaData: MetaData;
    metaData: MetaData;
    constructor(name: string | string[], level?: LogLevel);
    static setEmitErrors(emit?: boolean): void;
    static setEnvironmentId(environmentId?: string): void;
    static events: EventEmitter<{
        error: (...message: any[]) => void;
    }, any>;
    private getNameArray;
    createLogger(name: string | string[], level?: LogLevel): Logger;
    get logLevel(): string;
    setLogLevel(level: LogLevel | keyof typeof LogLevel): void;
    private formatMessage;
    private captureAndSend;
    emitHttpLogs(level: LogLevel, message: Message, { args, transformMeta }: EmitHttpOptions): void;
    /**
     * Emits an INFO type message to the backend for analysis and debugging
     */
    instrument(message: Message, options: InstrumentOptions & Record<string, unknown>): void;
    log(level: LogLevel, message: Message, ...args: any[]): void;
    logVerboseTroubleshootingMessage(message: string | Error | unknown, ...args: any[]): void;
    debug(message: Message, ...args: any[]): void;
    info(message: Message, ...args: any[]): void;
    warn(message: Message, ...args: any[]): void;
    error(message: Message, ...args: any[]): void;
}
