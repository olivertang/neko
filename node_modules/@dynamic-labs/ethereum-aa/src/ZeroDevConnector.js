'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { publicActions, custom, createWalletClient, toHex, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { walletClientToSmartAccountSigner, ENTRYPOINT_ADDRESS_V06 } from 'permissionless/utils';
import { EthereumWallet, isEthWalletConnector, chainsMap, confirmationTransport, unFormatTransaction, createViemUiTransaction } from '@dynamic-labs/ethereum-core';
import { WalletConnectorBase, eventListenerHandlers } from '@dynamic-labs/wallet-connector-core';
import { parseEvmNetworks, StorageService, DeferredPromise, parseChainId, DynamicError, wrapMethodWithCallback, TransactionGasCannotBeSponsoredError, InsufficientFundsError } from '@dynamic-labs/utils';
import { ZERO_DEV_LAST_USED_CHAIN_ID_KEY } from './constants.js';
import { logger } from './utils/logger.js';
import { createEcdsaKernelAccountClient } from './utils/createEcsdaKernelAccountClient.js';
import { getEcdsaValidator } from './utils/getEcdsaValidator.js';
import { getEntryPoint } from './utils/getEntryPoint.js';
import { getKernelVersion } from './utils/getKernelVersion.js';

class ZeroDevConnector extends WalletConnectorBase {
    constructor(opts) {
        var _a, _b, _c, _d;
        super(opts);
        // provider map maintains the kernel clients per chain
        this.providerMap = {};
        // eoa connector map maintains the eoa address and connector for each smart wallet address
        this.eoaConnectorMap = {};
        this.ChainWallet = EthereumWallet;
        this.connectedChain = 'EVM';
        this.supportedChains = ['ETH', 'EVM'];
        this.isGasSponsorshipDisabled = false;
        this.isEmbeddedWallet = true;
        this.providersFromApi = [];
        this.name = 'ZeroDev';
        this.overrideKey = 'zerodev';
        this.walletFallback = {
            brand: {
                alt: 'Smart Wallet',
                spriteId: 'smartwallet',
            },
            name: 'ZeroDev',
        };
        this._walletUiUtils = opts.walletUiUtils;
        this.evmNetworks = parseEvmNetworks(opts.evmNetworks);
        this.entryPoint = getEntryPoint((_a = opts.apiProviders.zerodev) === null || _a === void 0 ? void 0 : _a.entryPointVersion);
        this.kernelVersion = getKernelVersion((_b = opts.apiProviders.zerodev) === null || _b === void 0 ? void 0 : _b.kernelVersion, this.entryPoint);
        // this is the list of providers from the api that are used for multi-chain account abstraction
        this.providersFromApi =
            ((_c = opts.apiProviders.zerodev) === null || _c === void 0 ? void 0 : _c.multichainAccountAbstractionProviders) || [];
        const [defaultProvider] = this.providersFromApi;
        this.clientId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.clientId;
        if (!this.clientId) {
            throw new Error('Missing ZeroDev project ID provided. Add your ZeroDev project id to your project configuration via the Dynamic Labs dashboard.');
        }
        this.defaultChainId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.chain;
        this.ecdsaProviderType = (_d = opts.apiProviders.zerodev) === null || _d === void 0 ? void 0 : _d.ecdsaProviderType;
    }
    get currentNetworkProvider() {
        // check if the last used chain id is in the provider map
        if (this.providerMap[this.lastUsedChainId]) {
            return this.providerMap[this.lastUsedChainId];
        }
        // if not, check if the default chain id is in the provider map
        if (this.defaultChainId) {
            return this.providerMap[this.defaultChainId];
        }
        // if no chain id is found, return undefined
        return undefined;
    }
    get lastUsedChainId() {
        var _a;
        const storedChainId = StorageService.getItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        // returning string of unknown if no chain id is found to result in undefined provider lookup
        return (_a = storedChainId !== null && storedChainId !== void 0 ? storedChainId : this.defaultChainId) !== null && _a !== void 0 ? _a : 'unknown';
    }
    get kernelClient() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClient;
    }
    get kernelClientWithSponsorship() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClientWithSponsorship;
    }
    supportsNetworkSwitching() {
        return (Object.keys(this.providerMap).length > 1 && this.evmNetworks.length > 1);
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!this.supportsNetworkSwitching())
                return;
            if (!networkChainId)
                return;
            const chainId = networkChainId.toString();
            if (!this.providerMap[chainId]) {
                throw new Error(`No provider found for chainId: ${chainId}`);
            }
            StorageService.setItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY, chainId);
            const { handleChainChange } = eventListenerHandlers(this);
            handleChainChange(chainId);
        });
    }
    /**
     * @deprecated You should get the EOA connector by passing the SCW to getEOAConnector,
     * from the useSmartWallet hook
     */
    getEOAConnector() {
        return this.eoaConnector;
    }
    getAccountAbstractionProvider({ withSponsorship, } = {}) {
        if (withSponsorship && this.kernelClientWithSponsorship) {
            return this.kernelClientWithSponsorship;
        }
        return this.kernelClient;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            StorageService.removeItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        });
    }
    registerEoa(_a) {
        return __awaiter(this, arguments, void 0, function* ({ smartWalletAddress, eoaAddress, eoaConnector, shouldSetEoaConnector = false, ecdsaProviderType, kernelVersion, entryPointVersion, }) {
            const properties = {
                ecdsaProviderType,
                entryPointVersion,
                kernelVersion,
            };
            this.eoaConnectorMap[smartWalletAddress] = {
                eoaAddress,
                eoaConnector,
                properties,
            };
            // if this is the primary wallet, set the eoa connector and kernel clients
            if (shouldSetEoaConnector && this.eoaAddress !== eoaAddress) {
                yield this.setEoaConnector({
                    connector: eoaConnector,
                    eoaAddress,
                    properties,
                });
            }
        });
    }
    setEoaConnector(_a) {
        return __awaiter(this, arguments, void 0, function* ({ eoaAddress, connector, properties, }) {
            var _b;
            if (!connector) {
                logger.error('No EOA connector provided');
                return;
            }
            this.kernelClientDeferredPromise = new DeferredPromise();
            this.eoaConnector = connector;
            this.eoaAddress = eoaAddress;
            if (properties) {
                this.ecdsaProviderType =
                    (_b = properties.ecdsaProviderType) !== null && _b !== void 0 ? _b : this.ecdsaProviderType;
                this.entryPoint = properties.entryPointVersion
                    ? getEntryPoint(properties.entryPointVersion)
                    : this.entryPoint;
                this.kernelVersion = properties.entryPointVersion
                    ? getKernelVersion(properties.kernelVersion, this.entryPoint)
                    : this.kernelVersion;
            }
            if (isEthWalletConnector(this.eoaConnector) &&
                !this.eoaConnector.getActiveAccount()) {
                yield this.eoaConnector.getConnectedAccounts();
            }
            const signer = yield this.eoaConnector.getSigner();
            signer.account = toAccount(eoaAddress);
            yield this.generateProviderMap(signer);
            this.evmNetworks = this.evmNetworks.filter((network) => Boolean(this.providerMap[network.chainId]));
            this.kernelClientDeferredPromise.resolve();
        });
    }
    warnIfProjectChainNotEnabled(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let chainIdToCheck = chainId;
            if (!chainIdToCheck) {
                const client = yield this.getPublicClient();
                chainIdToCheck = (_a = client === null || client === void 0 ? void 0 : client.chain) === null || _a === void 0 ? void 0 : _a.id;
            }
            const isProjectChainEnabled = this.evmNetworks.some((network) => network.chainId === chainIdToCheck);
            if (!isProjectChainEnabled) {
                logger.error(`Please make sure to enable (${chainIdToCheck}) in the Dynamic dashboard (https://app.dynamic.xyz/dashboard/configurations#evm).`);
            }
        });
    }
    generateProviderMap(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            // reset the chains provider map when eoa connector changes
            this.providerMap = {};
            yield Promise.all(this.providersFromApi.map((provider) => __awaiter(this, void 0, void 0, function* () {
                if (!this.providerMap[provider.chain]) {
                    const [kernelClient, kernelClientWithSponsorship] = yield Promise.all([
                        this.getKernelClientWithoutSponsorshipValidation({
                            chainId: provider.chain,
                            projectId: provider.clientId,
                            signer,
                        }),
                        this.getKernelClientWithSponsorshipValidation({
                            chainId: provider.chain,
                            projectId: provider.clientId,
                            signer,
                        }),
                    ]);
                    this.providerMap[provider.chain] = {
                        kernelClient,
                        kernelClientWithSponsorship,
                    };
                }
                yield this.warnIfProjectChainNotEnabled(parseChainId(provider.chain));
            })));
        });
    }
    getKernelClientWithoutSponsorshipValidation(_a) {
        return __awaiter(this, arguments, void 0, function* ({ projectId, signer, chainId, }) {
            if (chainId && this.providerMap[chainId]) {
                return this.providerMap[chainId].kernelClient;
            }
            const { eoaConnector } = this;
            if (!eoaConnector)
                throw new DynamicError('No EOA connector');
            const kernelClient = yield createEcdsaKernelAccountClient({
                bundlerRpc: ZeroDevConnector.bundlerRpc,
                chain: chainsMap[chainId],
                ecdsaValidator: getEcdsaValidator(this.ecdsaProviderType),
                entryPointAddress: this.entryPoint,
                kernelVersion: this.kernelVersion,
                paymaster: 'NONE',
                paymasterRpc: ZeroDevConnector.paymasterRpc,
                projectId,
                provider: ZeroDevConnector.bundlerProvider,
                signer: walletClientToSmartAccountSigner(signer),
            });
            wrapMethodWithCallback(kernelClient, 'sendUserOperation', (original, ...args) => {
                this._walletUiUtils.disabledConfirmationOnce();
                return original(...args);
            });
            return kernelClient;
        });
    }
    getKernelClientWithSponsorshipValidation(_a) {
        return __awaiter(this, arguments, void 0, function* ({ projectId, signer, chainId, }) {
            if (chainId && this.providerMap[chainId]) {
                return this.providerMap[chainId].kernelClientWithSponsorship;
            }
            const { eoaConnector } = this;
            if (!eoaConnector)
                throw new DynamicError('No EOA connector');
            const kernelClientWithSponsorship = yield createEcdsaKernelAccountClient({
                bundlerRpc: ZeroDevConnector.bundlerRpc,
                chain: chainsMap[chainId],
                ecdsaValidator: getEcdsaValidator(this.ecdsaProviderType),
                entryPointAddress: this.entryPoint,
                kernelVersion: this.kernelVersion,
                paymaster: 'SPONSOR',
                paymasterRpc: ZeroDevConnector.paymasterRpc,
                projectId,
                provider: ZeroDevConnector.bundlerProvider,
                signer: walletClientToSmartAccountSigner(signer),
            });
            wrapMethodWithCallback(kernelClientWithSponsorship, 'sendUserOperation', (original, ...args) => {
                this._walletUiUtils.disabledConfirmationOnce();
                return original(...args);
            });
            return kernelClientWithSponsorship;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return (_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return ((_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address)
                ? [yield this.kernelClient.account.address]
                : [];
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return (_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.chain) === null || _c === void 0 ? void 0 : _c.id;
        });
    }
    getTransport(provider) {
        const transport = confirmationTransport({
            getAccounts: () => __awaiter(this, void 0, void 0, function* () { return [provider.account.address]; }),
            onPersonalSign: (_a) => __awaiter(this, [_a], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                return provider.signMessage({
                    message,
                });
            }),
            onSendTransaction: (_b) => __awaiter(this, [_b], void 0, function* ({ transaction }) {
                try {
                    this._walletUiUtils.disabledConfirmationOnce();
                    const effectiveProvider = this.isGasSponsorshipDisabled
                        ? provider
                        : this.kernelClientWithSponsorship;
                    if (!effectiveProvider) {
                        throw new DynamicError('No provider');
                    }
                    const response = yield effectiveProvider.sendTransaction(unFormatTransaction(transaction));
                    return response;
                }
                catch (err) {
                    logger.debug(err);
                    if (TransactionGasCannotBeSponsoredError.isErrorMessage(err)) {
                        throw new TransactionGasCannotBeSponsoredError();
                    }
                    if (InsufficientFundsError.isErrorMessage(err)) {
                        throw new InsufficientFundsError();
                    }
                    throw err;
                }
            }),
            onSignTypedData: (_c) => __awaiter(this, [_c], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                const signTypedData = JSON.parse(message);
                return provider.signTypedData({
                    domain: signTypedData.domain,
                    message: signTypedData.message,
                    primaryType: signTypedData.primaryType,
                    types: signTypedData.types,
                });
            }),
            provider: provider.extend(publicActions),
            transport: custom(provider),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this._walletUiUtils,
        });
        return transport;
    }
    getWalletClient(chainId) {
        const provider = this.kernelClient;
        if (!provider)
            return undefined;
        const transport = this.getTransport(provider);
        const walletClient = createWalletClient({
            account: toAccount(provider.account.address),
            chain: chainId ? chainsMap[chainId] : provider.chain,
            transport,
        });
        return walletClient;
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const provider = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.extend(publicActions);
            if (!provider)
                return undefined;
            return provider;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWalletClient();
        });
    }
    formatUserOperation(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            const entryPoint = (_a = this.getAccountAbstractionProvider()) === null || _a === void 0 ? void 0 : _a.account.entryPoint;
            const isV6 = (entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.toLowerCase()) === ENTRYPOINT_ADDRESS_V06.toLowerCase();
            if (isV6) {
                return {
                    callData: params.callData,
                    callGasLimit: toHex(params.callGasLimit),
                    initCode: (_c = (yield ((_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account.getInitCode()))) !== null && _c !== void 0 ? _c : '0x',
                    maxFeePerGas: toHex(params.maxFeePerGas),
                    maxPriorityFeePerGas: toHex(params.maxPriorityFeePerGas),
                    nonce: toHex(params.nonce),
                    paymasterAndData: params.paymasterAndData.toLowerCase(),
                    preVerificationGas: toHex(params.preVerificationGas),
                    sender: params.sender,
                    signature: '0x',
                    verificationGasLimit: toHex(params.verificationGasLimit),
                };
            }
            const accountGasLimits = '0x' +
                '000000000000000000000000000' + // 27 zeros
                toHex(params.verificationGasLimit).slice(2) +
                '000000000000000000000000000' + // 27 zeros
                toHex(params.callGasLimit).slice(2);
            const preVerificationGas = toHex(params.preVerificationGas);
            const gasFees = '0x' +
                '00000000000000000000000000' + // 26 zeros
                toHex(params.maxPriorityFeePerGas).slice(2).padStart(6, '0') +
                '0000000000000000000000' + // 22 zeros
                toHex(params.maxFeePerGas).slice(2).padStart(10, '0');
            const paymasterAndData = params.paymaster
                ? '0x' +
                    params.paymaster.slice(2).toLowerCase() +
                    toHex(params.paymasterVerificationGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    toHex(params.paymasterPostOpGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    params.paymasterData.slice(2) // Include full paymaster data
                : '0x';
            const initCode = (_e = (yield ((_d = this.kernelClient) === null || _d === void 0 ? void 0 : _d.account.getInitCode()))) !== null && _e !== void 0 ? _e : '0x';
            return {
                accountGasLimits: accountGasLimits,
                callData: params.callData,
                gasFees: gasFees,
                initCode,
                nonce: toHex(params.nonce),
                paymasterAndData: paymasterAndData.toLowerCase(),
                preVerificationGas: preVerificationGas,
                sender: params.sender,
                signature: '0x',
            };
        });
    }
    getCurrentUserOperation(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            try {
                const { kernelClientWithSponsorship } = this;
                if (!kernelClientWithSponsorship) {
                    throw new DynamicError('No kernel client with sponsorship found');
                }
                const value = BigInt((_a = transaction.value) !== null && _a !== void 0 ? _a : 0);
                const userOperation = {
                    callData: yield kernelClientWithSponsorship.account.encodeCallData({
                        data: transaction.data ? transaction.data : '0x',
                        to: transaction.to,
                        value,
                    }),
                };
                let sponsorResult;
                let unsponsoredResult;
                try {
                    sponsorResult =
                        yield kernelClientWithSponsorship.prepareUserOperationRequest({
                            account: kernelClientWithSponsorship.account,
                            userOperation,
                        });
                }
                catch (err) {
                    logger.debug('[ZeroDevConnector] Sponsored UserOp Attempt Failed:', err);
                    unsponsoredResult =
                        yield ((_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.prepareUserOperationRequest({
                            account: (_c = this.kernelClient) === null || _c === void 0 ? void 0 : _c.account,
                            userOperation,
                        }));
                }
                if ((sponsorResult === null || sponsorResult === void 0 ? void 0 : sponsorResult.paymasterAndData) === '0x')
                    return { sponsored: false, userOperation: sponsorResult };
                return sponsorResult
                    ? { sponsored: true, userOperation: sponsorResult }
                    : { sponsored: false, userOperation: unsponsoredResult };
            }
            catch (err) {
                logger.debug('[ZeroDevConnector] Error in getCurrentUserOperation:', err);
                return { sponsored: false, userOperation: undefined };
            }
        });
    }
    canSponsorTransactionGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sponsored } = yield this.getCurrentUserOperation(transaction);
            if (!sponsored) {
                return false;
            }
            return sponsored;
        });
    }
    disableGasSponsorshipOnce() {
        this.isGasSponsorshipDisabled = true;
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const rpcClient = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.extend(publicActions);
            if (!rpcClient)
                throw new DynamicError('No RPC client');
            return formatEther(yield rpcClient.getBalance({ address: address }));
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = this === null || this === void 0 ? void 0 : this.kernelClient;
            // https://docs.zerodev.app/sdk/core-api/sign-and-verify#signing-messages
            if (!client)
                throw new Error('Error fetching signer');
            return client.signMessage({ message: messageToSign });
        });
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const walletClient = this.getWalletClient();
            const publicClient = yield this.getPublicClient();
            if (!publicClient || !walletClient) {
                throw new DynamicError('No public client available');
            }
            return createViemUiTransaction({ from, publicClient, walletClient });
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const eoa = this.eoaConnectorMap[expectedAddress];
            if (!eoa) {
                throw new DynamicError('No EOA connector');
            }
            const { eoaAddress, eoaConnector, properties } = eoa;
            yield eoaConnector.validateActiveWallet(eoaAddress);
            yield this.setEoaConnector({
                connector: eoaConnector,
                eoaAddress,
                properties,
            });
        });
    }
}

export { ZeroDevConnector };
