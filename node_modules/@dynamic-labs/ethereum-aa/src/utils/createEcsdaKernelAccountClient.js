'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { createKernelAccount } from '@zerodev/sdk/accounts';
import { createZeroDevPaymasterClient, createKernelAccountClient } from '@zerodev/sdk/clients';
import { createPublicClient, http, isAddress } from 'viem';

const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
const isERC20 = (value) => isAddress(value);
const createEcdsaKernelAccountClient = (_a) => __awaiter(void 0, [_a], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, index, paymaster = 'SPONSOR', entryPointAddress, kernelVersion, ecdsaValidator, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const publicClient = createPublicClient({
        chain,
        transport: http(resolvedBundlerRpc),
    });
    const validator = yield ecdsaValidator(publicClient, {
        entryPoint: entryPointAddress,
        kernelVersion,
        signer,
    });
    const account = yield createKernelAccount(publicClient, {
        entryPoint: entryPointAddress,
        index,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    const zerodevPaymaster = createZeroDevPaymasterClient({
        chain: chain,
        entryPoint: entryPointAddress,
        transport: http(resolvedPaymasterRpc),
    });
    const kernelClient = createKernelAccountClient({
        account,
        bundlerTransport: http(resolvedBundlerRpc),
        chain,
        entryPoint: entryPointAddress,
        middleware: paymaster !== 'NONE'
            ? {
                sponsorUserOperation: (_b) => __awaiter(void 0, [_b], void 0, function* ({ userOperation }) {
                    const _userOperation = userOperation;
                    if (isERC20(paymaster)) {
                        return zerodevPaymaster.sponsorUserOperation({
                            entryPoint: entryPointAddress,
                            gasToken: paymaster,
                            userOperation: _userOperation,
                        });
                    }
                    return zerodevPaymaster.sponsorUserOperation({
                        entryPoint: entryPointAddress,
                        userOperation: _userOperation,
                    });
                }),
            }
            : undefined,
    });
    return kernelClient;
});

export { createEcdsaKernelAccountClient, getZeroDevBundlerRPC, getZeroDevPaymasterRPC };
