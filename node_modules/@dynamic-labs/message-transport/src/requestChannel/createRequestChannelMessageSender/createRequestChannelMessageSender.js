'use client'
import { getAckMessageType, TIMEOUT_DURATION } from '../utils/utils.js';

const createRequestChannelMessageSender = ({ requestType, messageSessionId, timeoutMap, onReceiveAck, messageTransport, onTimeout, params, }) => {
    const ackMessageType = getAckMessageType(requestType);
    const message = {
        args: params,
        messageSessionId,
        type: requestType,
    };
    // We must listen for acks
    const handleAckMessage = ({ messageSessionId: incomingSessionId, type: incomingType, }) => {
        if (incomingSessionId !== messageSessionId ||
            incomingType !== ackMessageType)
            return;
        clearTimeout(timeoutMap[messageSessionId]);
        delete timeoutMap[messageSessionId];
        onReceiveAck === null || onReceiveAck === void 0 ? void 0 : onReceiveAck();
    };
    const sendMessage = () => {
        const startTimer = () => {
            const timeoutTimer = setTimeout(onTimeout, TIMEOUT_DURATION);
            timeoutMap[messageSessionId] = timeoutTimer;
        };
        // If this message transport is currently blocked, we must only start
        // the timeout once the message is actually emitted
        // We don't just default to this because the onEmit option is only
        // present in the message transport if has the block decorator
        if ('isBlocked' in messageTransport && messageTransport.isBlocked()) {
            messageTransport.emit(message, { onEmit: startTimer });
            return;
        }
        // Now we emit the event to set off the request
        messageTransport.emit(message);
        // We start the timer immediately since the message was not blocked
        startTimer();
    };
    return { handleAckMessage, sendMessage };
};

export { createRequestChannelMessageSender };
