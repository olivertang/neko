'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var web3_js = require('@solana/web3.js');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var utils = require('@dynamic-labs/utils');

class SolanaWallet extends walletConnectorCore.Wallet {
    /**
     * Sends the native balance of the wallet to the given address.
     * @param amount - The amount of balance to send (in SOL).
     * @param toAddress - The address to send the balance to.
     * @returns The signature of the sent transaction.
     */
    sendBalance(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ amount, toAddress, }) {
            const connection = yield this.getConnection();
            const signer = yield this.getSigner();
            const { blockhash } = yield connection.getLatestBlockhash('finalized');
            const message = new web3_js.TransactionMessage({
                instructions: [
                    web3_js.SystemProgram.transfer({
                        fromPubkey: new web3_js.PublicKey(this.address),
                        lamports: utils.solToLamports(Number(amount)),
                        toPubkey: new web3_js.PublicKey(toAddress),
                    }),
                ],
                payerKey: new web3_js.PublicKey(this.address),
                recentBlockhash: blockhash,
            }).compileToV0Message();
            const transaction = new web3_js.VersionedTransaction(message);
            const { signature } = yield signer.signAndSendTransaction(transaction);
            return signature;
        });
    }
    /**
     * Retrieves the RPC connection
     * @returns A promise that resolves to the RPC connection
     */
    getConnection() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return this._connector.getWalletClient();
        });
    }
    /**
     * Retrieves the solana signer for the wallet.
     * @returns A promise that resolves to the signer,
     * or throws an error if the signer cannot be retrieved.
     */
    getSigner() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const signer = yield this._connector.getSigner();
            if (!signer) {
                throw new Error('unable to retrieve Solana signer');
            }
            try {
                return utils.cloneObjectWithOverrides(signer, {
                    signAllTransactions: (transactions) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signAllTransactions(transactions);
                    }),
                    signAndSendTransaction: (transaction, ...args) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signAndSendTransaction(transaction, ...args);
                    }),
                    signMessage: (message, ...args) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signMessage(message, ...args);
                    }),
                    signTransaction: (transaction) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signTransaction(transaction);
                    }),
                });
            }
            catch (error) {
                walletConnectorCore.logger.warn(`Failed to add logic to auto-sync the wallet. Signer might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
                return signer;
            }
        });
    }
}

exports.SolanaWallet = SolanaWallet;
