'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var web3_js = require('@solana/web3.js');
var splToken = require('@solana/spl-token');
var utils = require('@dynamic-labs/utils');

const LAMPORTS_PER_SOL = 1000000000;
class SolanaUiTransaction {
    constructor({ onSubmit, from, connection, multipleTransactions, }) {
        this.chain = 'SOL';
        this.data = undefined;
        this.fee = { gas: undefined };
        this.formatNonNativeToken = (value, decimals) => (Number(value) / Number(Math.pow(10, decimals))).toString();
        this.from = from;
        this.onSubmit = onSubmit;
        this.connection = connection;
        this.multipleTransactions = multipleTransactions;
    }
    fetchFee() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.fee.gas)
                return;
            let transactions = this.multipleTransactions;
            // for send balance flow, create the transaction and then estimate it
            if (!transactions) {
                const tx = yield this.createTransactionSafe();
                if (!tx)
                    return;
                transactions = tx instanceof Array ? tx : [tx];
            }
            const compiledMessages = yield Promise.all(transactions.map((tx) => _tslib.__awaiter(this, void 0, void 0, function* () {
                if ('version' in tx) {
                    return tx.message;
                }
                return tx.compileMessage();
            })));
            if (compiledMessages.some((msg) => !msg)) {
                throw new Error('Invalid transaction');
            }
            const getFeeWithRetry = (message) => _tslib.__awaiter(this, void 0, void 0, function* () {
                let res = yield this.connection.getFeeForMessage(message, 'confirmed');
                let retryCount = 0;
                while (res.value === null && retryCount < 5) {
                    res = yield this.connection.getFeeForMessage(message, 'confirmed');
                    retryCount++;
                }
                return res.value ? BigInt(res.value) : BigInt(0);
            });
            const fees = yield Promise.all(compiledMessages.map((message) => getFeeWithRetry(message)));
            this.fee.gas = fees.reduce((acc, fee) => acc + fee, BigInt(0));
            if (this.fee.gas === BigInt(0)) {
                this.fee.gas = undefined;
            }
        });
    }
    // if one of the transactions is not sponsored,
    // then the simulation will have a solana transfer in it if it was successful
    isGasSponsored() {
        var _a;
        if (!((_a = this.multipleTransactions) === null || _a === void 0 ? void 0 : _a.length))
            return false;
        return this.multipleTransactions.every((tx) => {
            var _a;
            if ('version' in tx) {
                return this.from !== tx.message.staticAccountKeys[0].toBase58();
            }
            if ('feePayer' in tx) {
                return this.from !== ((_a = tx.feePayer) === null || _a === void 0 ? void 0 : _a.toBase58());
            }
            return false;
        });
    }
    parse(input) {
        const floatValue = parseFloat(input);
        const lamports = Math.round(floatValue * LAMPORTS_PER_SOL);
        return BigInt(lamports);
    }
    parseNonNativeToken(input, decimals) {
        return BigInt(Math.floor(Number(input) * Math.pow(10, decimals)));
    }
    format(value, { precision } = {}) {
        const solValue = Number(value) / LAMPORTS_PER_SOL;
        const decimalString = solValue.toLocaleString('fullwide', {
            maximumFractionDigits: 20,
            minimumFractionDigits: 0,
            useGrouping: false,
        });
        return utils.formatNumberText(decimalString, { precision });
    }
    submit() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.multipleTransactions) {
                return this.onSubmit();
            }
            // send balance modal transactions
            const sendTransaction = (yield this.createTransaction());
            return this.onSubmit(sendTransaction);
        });
    }
    getBalance() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const publicKey = new web3_js.PublicKey(this.from);
            const balance = yield this.connection.getBalance(publicKey);
            return BigInt(balance);
        });
    }
    validateAddressFormat(address) {
        if (address === 'dyn_send_transaction.multiple_recipients') {
            return true;
        }
        return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
    }
    createTransaction() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const { value, to, nonNativeAddress: splTokenMintAddress, nonNativeValue, } = this;
            if (!to) {
                throw new Error('Destination is required');
            }
            if (this.multipleTransactions) {
                return this.multipleTransactions;
            }
            const sendTransaction = new web3_js.Transaction();
            const fromPubkey = new web3_js.PublicKey(this.from);
            const toPubkey = new web3_js.PublicKey(to);
            if (splTokenMintAddress && nonNativeValue) {
                const tokenMintPubkey = new web3_js.PublicKey(splTokenMintAddress);
                const amount = nonNativeValue;
                const fromTokenAccount = (_a = (yield this.connection.getTokenAccountsByOwner(fromPubkey, {
                    mint: tokenMintPubkey,
                })).value[0]) === null || _a === void 0 ? void 0 : _a.pubkey;
                if (!fromTokenAccount)
                    throw new Error('Source token account not found');
                let toTokenAccountPubkey;
                try {
                    toTokenAccountPubkey = yield splToken.getAssociatedTokenAddress(tokenMintPubkey, toPubkey);
                    yield this.connection.getTokenAccountBalance(toTokenAccountPubkey);
                }
                catch (_b) {
                    // If the recipient doesn't have a token account, create one
                    toTokenAccountPubkey = yield splToken.getAssociatedTokenAddress(tokenMintPubkey, toPubkey);
                    sendTransaction.add(splToken.createAssociatedTokenAccountInstruction(fromPubkey, toTokenAccountPubkey, toPubkey, tokenMintPubkey));
                }
                sendTransaction.add(splToken.createTransferInstruction(fromTokenAccount, toTokenAccountPubkey, fromPubkey, amount));
            }
            else {
                // Native SOL transfer
                const lamports = value !== null && value !== void 0 ? value : BigInt(0);
                sendTransaction.add(web3_js.SystemProgram.transfer({
                    fromPubkey,
                    lamports,
                    toPubkey,
                }));
            }
            // only set blockhash when we are creating the transaction, e.g send balance flow
            const { blockhash } = yield this.connection.getLatestBlockhash();
            sendTransaction.feePayer = new web3_js.PublicKey(this.from);
            sendTransaction.recentBlockhash = blockhash;
            return sendTransaction;
        });
    }
    createTransactionSafe() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.createTransaction();
            }
            catch (error) {
                return undefined;
            }
        });
    }
}

exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
exports.SolanaUiTransaction = SolanaUiTransaction;
