'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { PublicKey, Connection, Transaction, TransactionInstruction } from '@solana/web3.js';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { DynamicError, isLedgerAddressViaVerifiedCredentials, NotSupportedError } from '@dynamic-labs/utils';
import { SolanaWallet } from '../wallet/SolanaWallet.js';
import { extractNonce } from '../utils/extractNonce/extractNonce.js';
import { getGenesisHashLSKey } from '../utils/getGenesisHashLSKey/getGenesisHashLSKey.js';

const MEMO_PROGRAM_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
class SolanaWalletConnector extends WalletConnectorBase {
    constructor(opts) {
        var _a;
        super(opts);
        this.isHardwareWalletEnabled = false;
        this.verifiedCredentials = [];
        this.ChainWallet = SolanaWallet;
        this.supportedChains = ['SOL'];
        this.connectedChain = 'SOL';
        this.solNetworks = opts.solNetworks;
        this.chainRpcProviders = opts.chainRpcProviders;
        this.connectionConfig = opts.connectionConfig;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerSolanaProviders(this.connectionConfig);
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            let genesisHash = localStorage.getItem(getGenesisHashLSKey(provider.rpcEndpoint));
            if (!genesisHash) {
                genesisHash = yield provider.getGenesisHash();
                localStorage.setItem(getGenesisHashLSKey(provider.rpcEndpoint), genesisHash);
            }
            genesisHash = genesisHash.substring(0, 32);
            // see: https://github.com/ChainAgnostic/namespaces/blob/main/solana/caip2.md
            let network;
            if (genesisHash === '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp') {
                network = 'mainnet';
            }
            else if (genesisHash === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1') {
                network = 'devnet';
            }
            else {
                network = 'testnet';
            }
            return network;
        });
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            localStorage.removeItem(getGenesisHashLSKey(this.getWalletClient().rpcEndpoint));
        });
    }
    getWalletClient() {
        var _a, _b;
        const [network] = this.solNetworks;
        if (!network) {
            throw new DynamicError('No enabled networks');
        }
        const rpcUrl = ((_a = network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || network.rpcUrls[0];
        return new Connection(rpcUrl, (_b = this.connectionConfig) !== null && _b !== void 0 ? _b : 'confirmed');
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.solNetworks.length === 0)
                return;
            const configurations = {
                cosmos: [],
                evm: undefined,
                solana: this.solNetworks,
                starknet: undefined,
            };
            if (!this.chainRpcProviders)
                return undefined;
            const providers = this.chainRpcProviders.getProviders(configurations);
            return (_a = this.chainRpcProviders.getSolanaProviderByChainId(providers, '101')) === null || _a === void 0 ? void 0 : _a.provider;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = new PublicKey(address);
            const balance = this.lamportsToSol(yield this.getWalletClient().getBalance(publicKey));
            return balance.toString();
        });
    }
    // Solana uses lamports as the smallest unit of currency. This converts lamports to SOL.
    lamportsToSol(lamports) {
        return lamports / 1000000000;
    }
    canConnectWithHardwareWallet() {
        var _a;
        return Boolean((_a = this.metadata.supportedHardwareWallets) === null || _a === void 0 ? void 0 : _a.includes('ledger'));
    }
    signMessage(messageToSign) {
        const _super = Object.create(null, {
            signMessage: { get: () => super.signMessage }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isHardwareWalletEnabled) {
                throw new NotSupportedError(`Message signing is currently not supported on ${this.name} hardware wallet.
          You can use signMessageViaTransaction instead to achieve similar functionality
          by signing a transaction with a memo instruction.
          You can read more about it here https://github.com/solana-labs/solana/issues/21366`);
            }
            return _super.signMessage.call(this, messageToSign);
        });
    }
    proveOwnership(address, messageToSign) {
        const _super = Object.create(null, {
            proveOwnership: { get: () => super.proveOwnership }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(address);
            if (this.isHardwareWalletEnabled) {
                const nonce = extractNonce(messageToSign);
                if (!nonce) {
                    throw new DynamicError('Nonce missing');
                }
                return this.signMessageViaTransaction(nonce);
            }
            return _super.proveOwnership.call(this, address, messageToSign);
        });
    }
    signMessageViaTransaction(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            if (!address) {
                throw new DynamicError('Address missing');
            }
            const transaction = this.buildAuthTx(messageToSign);
            transaction.feePayer = new PublicKey(address);
            transaction.recentBlockhash = (yield this.getWalletClient().getLatestBlockhash()).blockhash;
            const signer = yield this.getSigner();
            if (!signer) {
                throw new DynamicError('Signer not found');
            }
            const signedTransaction = yield signer.signTransaction(transaction);
            const serializedSignedTransaction = signedTransaction.serialize();
            /**
             * Serializing the transaction and adding the type 'Buffer' is required
             * when connecting with backpack + Ledger, because the returned object is not correctly
             * serialized
             */
            return JSON.stringify({
                signedTransaction: {
                    data: Array.from(serializedSignedTransaction),
                    type: 'Buffer',
                },
            });
        });
    }
    buildAuthTx(message) {
        const transaction = new Transaction();
        transaction.add(new TransactionInstruction({
            data: Buffer.from(message, 'utf8'),
            keys: [],
            programId: MEMO_PROGRAM_ID,
        }));
        return transaction;
    }
    setVerifiedCredentials(verifiedCredentials) {
        this.verifiedCredentials = verifiedCredentials;
    }
    isLedgerAddress(address) {
        return isLedgerAddressViaVerifiedCredentials(address, this.verifiedCredentials);
    }
}

export { SolanaWalletConnector };
